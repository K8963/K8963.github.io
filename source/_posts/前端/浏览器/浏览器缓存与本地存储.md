---
title: 浏览器缓存与本地存储
date: 2021-05-09 07:59:00
comments: false
author: 8963
tags:
  - 浏览器
categories:
  - 前端
---

浏览器缓存机制：

- 强缓存、协商缓存、缓存位置

浏览器本地存储：

- Cookie
- WebStorage(localStorage、sessionStorage)
- IndexedDB

<!-- more -->

# 浏览器缓存

## 强缓存

浏览器中的缓存作用分为两种情况：

1. 需要发送 HTTP 请求
2. 不需要发送

首先通过相应的字段检查强缓存，这阶段不需要发送 HTTP 请求。

在 `HTTP/1.0` 和 `HTTP1.1` 中这个字段是不一样的。

- `HTTP/1.0`使用的是**Expires**
- `HTTP/1.1`使用的是**Cache-Control**

### Expires

expires 即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。

例如：

```http
Expires: Wed, 22 Nov 2021 08:41:00 GMT
```

表示资源在`2021年11月22号8点41分`过期，过期了就得向服务端发请求。

这种方式的缺点就是：服务器的时间和浏览器的时间可能不一致，那服务器返回的这个过期时间可能就是不准确的。

### Cache-Control

在 HTTP1.1 中,采用过期时长来控制缓存，对应的字段是 max-age。

```
Cache-Control:max-age=3600
```

代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存。
此字段其他属性:

- public: 客户端和代理服务器都可以缓存。
- private： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。
- no-cache: 跳过当前的强缓存，发送 HTTP 请求，即直接进入协商缓存阶段。
- no-store：非常粗暴，不进行任何形式的缓存。
- s-maxage：这和 max-age 长得比较像，但是区别在于 s-maxage 是针对代理服务器的缓存时间。

当 Expires 和 Cache-Control 同时存在的时候，**Cache-Control**会优先考虑。

## 协商缓存

强缓存失效之后，浏览器在请求头中携带相应的缓存 tag 来向服务器发请求，由服务器根据这个 tag，来决定是否使用缓存，这就是协商缓存。
缓存 tag 分为两种: Last-Modified 和 ETag。

### Last-Modified

即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。
浏览器接收到后，如果再次请求，会在请求头中携带 If-Modified-Since 字段，这个字段的值也就是服务器传来的最后修改时间。

服务器拿到请求头中的 If-Modified-Since 的字段后，其实会和这个服务器中该资源的最后修改时间对比:

- 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的 HTTP 请求响应的流程一样。
- 否则返回 304，告诉浏览器直接用缓存。

### ETag

ETag 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。
浏览器接收到 ETag 的值，会在下次请求时，将这个值作为 If-None-Match 这个字段的内容，并放到请求头中，然后发给服务器。

服务器接收到 If-None-Match 后，会跟服务器上该资源的 ETag 进行比对:

- 如果两者不一样，说明要更新了。返回新的资源，跟常规的 HTTP 请求响应的流程一样。
- 否则返回 304，告诉浏览器直接用缓存。

## 两者对比

1. 在精准度上，ETag 优于 Last-Modified。优于 ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:

- 编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。
- Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。

2. 在性能上，Last-Modified 优于 ETag，也很简单理解，Last-Modified 仅仅只是记录一个时间点，而 Etag 需要根据文件的具体内容生成哈希值。

如果两种方式都支持的话，服务器会优先考虑**ETag**。

## 缓存位置

当强缓存命中或者协商缓存中服务器返回 304 的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？
浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache

### Service Worker

Service Worker 借鉴了 Web Worker 的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问 DOM。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是 Service Worker Cache。

### Memory Cache\Disk Cache

Memory Cache 指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。

Disk Cache 就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。

使用 Memory Cache 还是 Disk Cache:

- 比较大的 JS、CSS 文件会直接被丢进磁盘，反之丢进内存
- 内存使用率比较高的时候，文件优先进入磁盘

### Push Cache

即推送缓存，这是浏览器缓存的最后一道防线。它是 HTTP/2 中的内容，虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛。

具体可以查看[扩展文章](https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/)。

# 本地存储

浏览器本地存储：

- Cookie
- WebStorage(localStorage、sessionStorage)
- IndexedDB

## Cookie

Cookie 最开始被设计出来其实并不是来做本地存储的，而是为了弥补 HTTP 在状态管理上的不足。
HTTP 协议是一个无状态协议，客户端向服务器发请求，服务器返回响应，故事就这样结束了，但是下次发请求如何让服务端知道客户端是谁呢？
Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在 chrome 开发者面板的 Application 这一栏可以看到)。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。

Cookie 的作用很好理解，就是用来做状态存储的，但它也是有诸多致命的缺陷的：

1. 容量缺陷。Cookie 的体积上限只有 4KB，只能用来存储少量的信息。
2. 性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。
3. 安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在 HttpOnly 为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。

## localStorage

与 Cookie 不同,localStorage 在同一个域名下，会存储相同的一段 localStorage。
与 Cookie 区别:

1. 容量。localStorage 的容量上限为 5M，相比于 Cookie 的 4K 大大增加。当然这个 5M 是针对一个域名的，因此对于一个域名是持久存储的。
2. 只存在客户端，默认不参与与服务端的通信。这样就很好地避免了 Cookie 带来的性能问题和安全问题。
3. 接口封装。通过 localStorage 暴露在全局，并通过它的 setItem 和 getItem 等方法进行操作，非常方便。

**操作方式**

```javascript
let obj = { name: "sanyuan", age: 18 };
localStorage.setItem("name", "sanyuan");
localStorage.setItem("info", JSON.stringify(obj));
// 进入域名获取值
let name = localStorage.getItem("name");
let info = JSON.parse(localStorage.getItem("info"));
```

**应用场景**

利用 localStorage 的较大容量和持久特性，可以利用 localStorage 存储一些内容稳定的资源，比如官网的 logo，存储 Base64 格式的图片资源，因此利用 localStorage

## sessionStorage

sessionStorage 以下方面和 localStorage 一致:

- 容量。容量上限也为 5M。
- 只存在客户端，默认不参与与服务端的通信。
- 接口封装。除了 sessionStorage 名字有所变化，存储方式、操作方式均和 localStorage 一样。

**应用场景**

1. 可以用它对表单信息进行维护，将表单信息存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。
2. 可以用它存储本次浏览记录。如果关闭页面后不需要这些记录，用 sessionStorage 就再合适不过了。事实上微博就采取了这样的存储方式。

## IndexedDB

IndexedDB 是运行在浏览器中的非关系型数据库, 本质上是数据库，绝不是和刚才 WebStorage 的 5M 一个量级，理论上这个容量是没有上限的。
[使用文档](https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Using_IndexedDB)

**IndexedDB 的重要特性**

1. 键值对存储。内部采用对象仓库存放数据，在这个对象仓库中数据采用键值对的方式来存储。
2. 异步操作。数据库的读写属于 I/O 操作, 浏览器中对异步 I/O 提供了支持。
3. 受同源策略限制，即无法访问跨域的数据库。

# 总结

对于浏览器的缓存机制:
首先通过 `Cache-Control`验证强缓存是否可用.

- 如果强缓存可用,直接使用.
- 否则进入协商缓存阶段
  - 若资源更新,返回资源和 200 状态码
  - 否则,返回 304,告诉浏览器直接从缓存获取资源

浏览器本地存储方案:

1. cookie 并不适合存储，而且存在非常多的缺陷。
2. Web Storage 包括 localStorage 和 sessionStorage, 默认不会参与和服务器的通信。
3. IndexedDB 为运行在浏览器上的非关系型数据库，为大型数据的存储提供了接口。
