---
title: 模块化与包
date: 2021-07-18 21:52:39
comments: false
author: 8963
tags:
  - JavaScript
  - Node.js
categories:
  - 后端
---



# 模块化

概念：模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元。

编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个小模块。

把代码进行模块化拆分的好处:

1. 提高了代码的复用性
2. 提高了代码的可维护性
3. 可以实现按需加载

模块化规范：

模块化规范就是对代码进行模块化的拆分和组合时，需要遵守的规则



# Nodejs中的模块化

Node.js 中根据模块来源的不同，将模块分为了3大类，分别是:

- **内置模块**(内置模块是由Node.js 官方提供的，例如fs、path、http等)
  心
- **自定义模块**(用户创建的每个.js文件，都是自定义模块)
- **第三方模块**(由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载)



## 加载模块

使用强大的`require()`方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用。

## 模块作用域

和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域。

## module对象

可向外共享模块作用域中的成员

在每个.js自定义模块中都有一个module对象，它里面存储了和当前模块有关的信息

**module.exports**

在自定义模块中，可以使用module.exports 对象，将模块内的成员共享出去，供外界使用。

自定义模块

```javascript
const name = "zs";
function sayHello() {
  console.log("hello,my name is " + name);
}
module.exports = {
  name,
  sayHello,
};

```

使用自定义模块

```javascript
const m = require("./module.exports");

console.log(m);
```

 

## exports 对象

由于`module.exports`单词写起来比较复杂，为了简化向外共享成员的代码，Node提供了`exports`对象。默认情况下，`exports`和`module.exports` 指向同一个对象。最终共享的结果，还是以`module.exports` 指向的对象为准。

```javascript
module.exports === exports; // true
```



# Common JS

Node.,js 遵循了CommonJS模块化规范，CommonJS规定了模块的特性和各模块之间如何相互依赖。

CommonJS规定:

- 每个模块内部，module变量代表当前模块。
- module变量是一个对象，它的exports属性(即module.exports）是对外的接口。
- 加载某个模块，其实是加载该模块的module.exports属性。
- require()方法用于加载模块。



# 包

在Nodejs中**第三方模块**又叫做包

包是基于内置模块封装出来的，提供了更高级、更方便的APl，极大的提高了开发效率。

## 包的来源

包是由第三方个人或者团队开发出来的，免费供所有人使用

## npm包使用

### 格式化时间 - 传统做法

1. 创建格式化时间的自定义模块
2. 定义格式化时间的方法
3. 创建补零函数
4. 从自定义模块中导出格式化时间的函数
5. 导入格式化时间的自定义模块
6. 调用格式化时间的函数

```javascript
// dateFormat
// 定义时间格式化
function dateFormat(dtStr) {
  const dt = new Date(dtStr);

  const y = dt.getFullYear();
  const m = padZero(dt.getMonth() + 1);
  const d = padZero(dt.getDate());

  const hh = padZero(dt.getHours());
  const mm = padZero(dt.getMinutes());
  const ss = padZero(dt.getSeconds());

  return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;
}

// 补零函数
function padZero(n) {
  return n > 9 ? n : "0" + n;
}

module.exports = {
  dateFormat,
};
```

使用`dateFormat`

```javascript
const TIME = require("./dateFormat");

const dt = new Date();
// console.log(dt);

const newDt = TIME.dateFormat(dt);
console.log(newDt);
// 2022-01-24
```

### 使用第三方包进行格式化

1. 安装格式化时间包 - `monent`
2. 使用require()导入格式化时间的包
3. 参考moment的[官方API文档](http://momentjs.cn/)对时间进行格式化

```javascript
const moment = require("moment");

const dt = moment().format("YYYY-MM-DD HH:mm:ss");

console.log(dt);
```



## npm包注意

初次装包完成后，在项目文件夹下多一个叫做`node_modules`的文件夹和 `package-lock.json`的配置文件。

> `node_modules`文件夹用来存放所有已安装到项目中的包。require()导入第三方包时，就是从这个目录中查找并加载包。
>
> `package-lock.json`配置文件用来记录node modules 目录下的每一个包的下载信息，例效包的名字、版本号、下载地址等。

默认情况下，使用npm install 命令安装包的时候，会自动安装最新版本的包。如果需要安装指定版本的包，可以在包名之后，通过@符号指定具体的版本，例如:

```
npm i moment@2.22.2
```



包的语义化版本规范

包的版本号是以“点分十进制”形式进行定义的，总共有三位数字，例如2.24.0其中每一位数字所代表的的含义如下:

- 第1位数字:大版本
- 第2位数字:功能版本
- 第3位数字:Bug修复版本



## 包管理配置文件

npm 规定，在项目根目录中，必须提供一个叫做 `package.json`的包管理配置文件。用来记录与项目有关的一些配置信息。例如:

- 项目的名称、版本号、描述等
- 项目中使用的包
- 对包进行分类：开发和部署

创建 `package.json`的包管理配置文件

```
npm init -y
```

### dependencies

package.json文件中，有一个dependencies节点，专门用来记录您使用npm install命令安装了哪些包。

### devDependcies

如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到`devDependencies`节点中。

```
npm i moment -D
# or
npm i moment --save-dev
```

与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到`dependencies` 节点中。

查看npm各项配置

```
npm config get
```

查看当前下包的镜像源：

```
npm config get registry
```

## nrm

为了更方便的切换下包的镜像源，我们可以安装nrm这个小工具，利用nrm提供的终端命令，可以快速查看和切换下包的镜像源。

```
# #通过npm包管理器，将nrm安装为全局可用的工具
npm i nrm -g
# #查看所有可用的镜像源nrm ls
nrm ls
# #将下包的镜像源切换为taobao镜像
nrm use taobao
```



## 包的分类

项目包又分为两类，分别是:

- 开发依赖包

  被记录到`devDependencies`节点中的包，只在开发期间会用到

  ```
  npm i 包名 -D
  ```

  

- 核心依赖包

  被记录到`dependencies`节点中的包，在开发期间和项目上线之后都会用到

  ```
  npm i 包名 []
  ```



> 全局包 -g
>
> `--save` = `-S`
>
> 项目（运行时、发布到生产环境时）依赖 , devDependencies
>
> `--save-dev` = `-D`
>
> 工程构建（开发时、“打包”时）依赖 , dependencies



## 规范的包文件

1. 包必须以单独的目录而存在
2. 包的顶级目录下要必须包含 package.json这个包管理配置文件
3. package.json中必须包含name，version，main这三个属性，分别代表包的名字、版本号、包的入口。



# 开发自己的包

尝试开发自己的包：

1. 格式化日期
2. 转义HTML中的特殊字符
3. 还原HTML中的特殊字符

## 初始化包基本结构

1. 新建8963-tools 文件夹，作为包的根目录
2. 在8963-tools文件夹中，新建如下三个文件:

   - package.json(包管理配置文件)

- index.js(包的入口文件)

3. README.md(包的说明文档)



## 将包发布到npm

将终端切换到包的根目录之后，运行npm publish 命令，即可将包发布到npm上(注意:包名不能雷同)。

![](https://cdn.jsdelivr.net/gh/K8963/Imageshack@main/blog/202209070835908.png)

删除已经发布的包

```
npm unpublish 包名 --force
```

注意：

- npm unpublish命令只能删除72小时以内发布的包
- npm unpublish 删除的包,在24小时内不允许重复发布

![](https://cdn.jsdelivr.net/gh/K8963/Imageshack@main/blog/202209070836403.png)





# 模块的加载机制

模块在第一次加载后会被缓存。这也意味着多次调用require)不会导致模块的代码被执行多次。

注意:不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。

## 内置模块加载机制

内置模块是由Node.js 官方提供的模块，内置模块的加载优先级最高。

例如，require('fs')始终返回内置的fs模块，即使在node modules目录下有名字相同的包也叫做fs。



## 自定义模块加载机制

使用require()加载自定义模块时，必须指定以`./`或`../`开头的路径标识符。

在加载自定义模块时，如果没有指定`./`或`../`这样的路径标识符，则node会把它当作内置模块或第三方模块进行加载。

同时，在使用require()导入自定义模块时，如果省略了文件的扩展名，则Node.js 会按顺序分别尝试加载以下的文件:

1. 按照确切的文件名进行加载

2. 补全`.js`扩展名进行加载

3. 补全`.json`扩展名进行加载

4. 补全`.node`扩展名进行加载



## 第三方模块加载机制

如果传递给`require()`的模块标识符不是一个内置模块，也没有以`./`或‘`../`开头，则Nodejs 会从当前模块的父目录开始，尝试从`/node_modules`文件夹中加载第三方模块。

如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。



## 把目录当作模块加载

当把目录作为模块标识符，传递给require()进行加载的时候，有三种加载方式:

1. 在被加载的目录下查找一个叫做package.json的文件，并寻找 main属性，作为require()加载的入口
2. 如果目录里没有package.json文件，或者main入口不存在或无法解析，则Node,js,将会试图加载目录下的 indexjs文件。
3. 如果以上两步都失败了，则Node.,js 会在终端打印错误消息，报告模块的缺失;Error: Cannot find module 'xo'





